module Clojure.Translate where

import Language.Haskell.Exts.Syntax as HS
import Clojure.Syntax as Sexp


class Translateable a where
    translate :: a -> Package


instance Translateable Module where
    translate a = translateModule a


translateModule :: Module -> Package
translateModule (Module _  modname _  _ _ _ decl) = 
    Package "thispackage" (foldr (\x -> ((translateDecl x)++)) [] decl)


translateDecl :: Decl -> [Sexp]
translateDecl (FunBind matches) = map (translateMatch) matches


translateQName :: QName -> Atom
translateQName (UnQual x) = translateName x

translateQOP :: QOp -> Sexp
translateQOP (QVarOp x) = Atomic (translateQName x)



translateExp :: Exp -> Sexp
translateExp (HS.Var x ) = 
    Atomic (translateQName x)
translateExp (HS.InfixApp a sym b) = 
    InfixApply (translateExp a) (translateQOP sym) (translateExp b)




translateMatch :: Match -> Sexp
translateMatch (Match _  name patlist  _   (UnGuardedRhs rhs) binds) 
    = 
      let sexpPattern = map (translatePattern) patlist
      in Func (translateName name) (Pat sexpPattern)  [(Pat sexpPattern, translateExp rhs)]
                  


translateLiteral::  Literal -> Atom
translateLiteral (HS.Char x) = (Sexp.Lit x)

translateName :: Name -> Atom
translateName (HS.Ident x) = Sexp.Ident x
translateName (HS.Symbol x) = Sexp.Symbol x

translatePattern :: Pat -> Atom
translatePattern (PVar x) = (translateName x)
translatePattern (PLit (Char x)) = Sexp.Lit x


