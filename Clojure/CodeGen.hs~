{-
CodeGen.hs

the code generation step to convert a clojure syntax AST to executeable code
-}

module CodeGen where

import Data.List


import Syntax



class Generateable a where 
    gen  :: a -> String

instance Generateable Package where
   gen a = genPackage a
    
instance Generateable Sexp where
    gen x = gensexp x 0


genPackage :: Package -> String
genPackage (Package name functions)  = concat $ map (\x -> (gensexp x 0)) functions


gensexp :: Sexp -> Int -> String
gensexp Nil spaces = (indent spaces) ++ "Nil"
gensexp (Atomic x) spaces = gen x
gensexp (Func name (Pat x) bodies) spaces = 
    genfunction (genatom name) (map (genatom) x) bodies spaces
gensexp (List x) spaces = 
    "(" ++ (foldr (\y -> (((gen y)++ " ") ++)) [] x) ++ ")"
gensexp (InfixApply x op z) spaces = 
    "(" ++ (gensexp op spaces) ++ " "
                  ++ (gensexp x spaces) ++ " " 
                  ++ (gensexp z spaces) ++ ")"


genfunction :: String -> [String] -> [(Pattern, Sexp)]  -> Int -> String
genfunction name params bodies  spaces = 
             let genpair :: Int -> (Pattern, Sexp) -> [Char]
                 genpair spaces (Pat x,y) = 
                     (indent spaces) ++ "((match " 
                                         ++ (concat $ map (genatom) x) 
                                         ++ ") " ++ (concat params) 
                                         ++ (gensexp y spaces)
                 genpair spaces (Ptrue, y) = 
                     (indent spaces) 
                     ++ "(t " ++ (gensexp y spaces)
             in              
             "(defn " ++  name ++ " " ++ "[" ++ 
                          (concat (intersperse " " params)) 
                          ++ "]" ++ "\n" ++ 
                          (indent 3) ++ 
                               if length bodies == 1 then 
                                   (gen (snd . head $ bodies)) ++ ")\n"
                               else 
                                "(cond \n" ++  
                               (concat (intersperse "\n" 
                                        (map (genpair (spaces+5)) bodies))) 
                               ++ ")) \n"




instance Generateable Atom where
    gen x = genatom x






genatom :: Atom -> String
genatom (Lit x) = (show x)
genatom (String x) = x
genatom (Ident x) = x
genatom (Var x) = x
genatom (Symbol x) = x
